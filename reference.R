if(pre_adaptation == F){gen_number_pre_adaptation <- 0}
# if(neutral_simulations == T){selection <- F}
# This is the total number of generations
number_generations <- gen_number_pre_adaptation + gen_number_dispersal
##### REFERENCE TABLES FOR GENERAL SIMULATIONS #####
if(simulation_type == "general"){
chromosome_length <- windows_gral * map_resolution
# The recombination map is generated by creating a table with as many rows as loci_number_to_simulate 
# and one column, which is filled with the recombination rate between loci (c_gral).
map <- as.data.frame(matrix(nrow = windows_gral))
map[,1] <- c_gral/100
map[,2] <- 1
colnames(map) <- c("cM","non_synonymous")
# Adjusting the total number of loci to simulate by adding one more locus to each window because each 
# window (row) contains one msat.  This is done with the aim that the number of adaptive loci and the 
# number of neutral loci are completely independent from each other
# The neutral locus is located at the middle of the window
location_neutral_loci_analysis <- seq(map_resolution/2,(nrow(map)*map_resolution),map_resolution)
# the number of potentially adaptive loci and the number of potentially neutral loci are added to obtain 
# the total number of loci per 100 Kbp window
loci_number_to_simulate <- loci_number_to_simulate + nrow(map)
map$NS_density <- ceiling(map$non_synonymous / (sum(map$non_synonymous) / loci_number_to_simulate))
# To determine the location of each locus in the chromosome, first the cM’s and the 100 Kbps are divided 
# between the total number of loci. Then, each locus is placed along the chromosome sequentially using the 
# accumulative sum of cM’s and Kbps for each locus. 
recombination_map <- NULL
for (value in 1:nrow(map)) {
  temp <- NULL
  temp <- as.data.frame(rep((map[value, "cM"]/map[value, "NS_density"]),map[value, "NS_density"]))
  distance <- map_resolution / nrow(temp)
  temp$loc_bp <- distance * (1:nrow(temp))
  if(value==1){
    temp$loc_bp <- ceiling(temp$loc_bp)
  }else{
  temp$loc_bp <- ceiling(temp$loc_bp + ((value * map_resolution)-map_resolution))
  }
  recombination_map <- rbind(recombination_map, temp)
}
# The last element of the first column must be zero, otherwise the recombination function crashes. 
recombination_map[nrow(recombination_map),1] <- 0
loci_number <- nrow(recombination_map)
# In order for the recombination rate to be accurate, we must account for the case when the probability of the total recombination rate is less than 1 (i.e. < 100 cM) or more than 1 (> 100 cM). For the first case, the program subtracts from 1 the sum of all the recombination rates and this value inserted in the last row of the recombination_map table. If this row is chosen as the recombination point, recombination does not occur. For example, if a chromosome of 20 cM’s is simulated, the last row of the recombination_map will have a value of 0.8 and therefore 80% of the times recombination will not occur. For the second case, having more than 100 cM, means that more than 1 recombination event occurs. So, one recombination event is perform for each 100 cM. Then, the program subtracts the number of recombination events from the sum of all the recombination rates and this value inserted in the last row of the recombination_map table, in the same way as in the first case. 
# number of recombination events per meiosis
recom_event <- ceiling((c_gral * windows_gral) / 100)
total_cM <- (c_gral * windows_gral)
# filling the probability of recombination when the total recombination rate is less than an integer (recom_event) and placing it at the end of the recombination map    
recombination_map[loci_number + 1,1] <-  recom_event - sum(recombination_map[, 1])
  # sum(recombination_map[, 1]) / recom_event 
recombination_map[loci_number + 1,2] <- recombination_map[loci_number,2]
recombination_map$accum <- cumsum(recombination_map[, 1])
location <- lapply(location_neutral_loci_analysis, findInterval,vec = as.numeric(paste(unlist(recombination_map$loc_bp))))
location[[1]] <- 1
colnames(recombination_map) <- c("c","locations_deleterious", "accum")

neutral_loci_location <-  as.character(location)
loci_location <- location
reference <- as.data.frame(matrix(nrow = loci_number))
reference$q <- q_gral
reference$h <- h_gral
reference$s <- s_gral
loci_number <- nrow(recombination_map)-1
reference$location <- recombination_map[1:loci_number,2]



}
if(starting_pops==F){
##### REFERENCE TABLES FOR FLY SIMULATIONS #####
if(simulation_type == "fly") {
  recombination_map_temp <- map
  locations_deleterious <- NULL
  if (simulation_type_2=="fly"){
    targets$targets_temp <- targets$ns - targets$s 
     # ns_proxy <- summary(targets$targets_temp)[2] * -1
     targets$targets <-  targets$targets_temp * targets_factor
    # ceiling(targets$ns + (targets$s * targets$CUB_dmel))/10
     targets <- targets[which(targets$targets>0),]
    }
  if (simulation_type_2=="chillingham"){
    targets$targets <- targets$ns * targets_factor
      # targets_factor
    # targets$targets <- ceiling(targets$ns + (targets$s * targets$CUB_dmel))/50
    }
  transcripts <- as.data.frame(targets)
 for(i in 1:nrow(transcripts)){
   locations_deleterious_temp <- unlist(mapply(FUN = function(a, b){seq(from = a, to = b, by = 4)}, a = unname(unlist(transcripts[i,"start"])), b = unname(unlist(transcripts[i,"end"]))))
   locations_deleterious_temp <- sample(locations_deleterious_temp,size = transcripts[i,"targets"])
   locations_deleterious <- c(locations_deleterious,locations_deleterious_temp)
 }
# here are added the location of the loci genotyped in the fly experiment
  if(experiment_loci==T){
    # these are the location of the neutral loci in the simulations
location_neutral_loci_analysis <- c(seq(map_resolution/2,(nrow(recombination_map_temp)*map_resolution),map_resolution),location_msats_experiment)
location_neutral_loci_analysis <- location_neutral_loci_analysis[order(location_neutral_loci_analysis)]
    locations_deleterious <- c(locations_deleterious,location_neutral_loci_analysis)
  }
  if(experiment_loci==F){
    location_neutral_loci_analysis <- seq(map_resolution/2,(nrow(recombination_map_temp)*map_resolution),map_resolution)
    locations_deleterious <- c(locations_deleterious,location_neutral_loci_analysis)
    }
locations_deleterious <- locations_deleterious[order(locations_deleterious)]
# different transcripts can be located in the same genome location So, repeated deleterious mutations are deleted, however transcripts that are in the same place are taken in account to calculate fitness in the fitness function
locations_deleterious <- unique(locations_deleterious)

    if(experiment_freq==T){
loc_exp_loci <- location_neutral_loci_analysis
loc_exp_loci <- loc_exp_loci[order(loc_exp_loci)]
loc_exp_loci <- which(loc_exp_loci %% 10000 != 0)    
loc_exp_loci_2 <- unlist(lapply(location_msats_experiment, function(x){which(x==locations_deleterious)}))
}

chromosome_length <- (nrow(recombination_map_temp)+1) * map_resolution
############################################################
################# DOUBLE CHECK ####################
############################################################
#this is to fix a bug that crashes the program because the last neutral locus soimetimes could be located farther than the last deleterious mutation
locations_deleterious <- c(locations_deleterious,chromosome_length)
############################################################
############################################################
############################################################
loci_number_to_simulate <- length(locations_deleterious)
# the recombination map is produced by cross multiplication. the following lines are the input for doing the cross multiplication. 
recombination_map_temp$midpoint <- seq(map_resolution/2,nrow(recombination_map_temp)*map_resolution,map_resolution)
recombination_temp <- unlist(lapply(locations_deleterious, findInterval, vec = as.numeric(paste(unlist(recombination_map_temp$midpoint)))))
# deleterious mutations located below the location in the first row of the recombination map (i.e. 50000) are assigned to row 0, to correct this they are reassigned to row number 1 
recombination_temp[recombination_temp==0] <- 1
recombination_2 <- recombination_map_temp[recombination_temp,"cM"]
recombination_map <- as.data.frame(cbind(locations_deleterious,recombination_2))
recombination_map$c <- NA
# the recombination map is produced by cross multiplication
#not taking in account the last row for the loop to work
for(deleterious_row in 1:(nrow(recombination_map)-1)){
  recombination_map[deleterious_row,"c"] <- ((recombination_map[deleterious_row+1,"locations_deleterious"] - recombination_map[deleterious_row,"locations_deleterious"]) * recombination_map[deleterious_row,"recombination_2"]) / map_resolution
}
# The last element of the recombination column must be zero, otherwise the recombination function crashes. 
recombination_map[nrow(recombination_map),"c"] <- 0 
loci_number <- loci_number_to_simulate
# In order for the recombination rate to be accurate, we must account for the case when the probability of 
# the total recombination rate is less than 1 (i.e. < 100 cM). For this end, the program subtracts from 1 
# the sum of all the recombination rates and this value inserted in the last row of the recombination_map
# table. If this row is chosen as the recombination point, recombination does not occur. For example, if a
# chromosome of 20 cM’s is simulated, the last row of the recombination_map will have a value of 0.8 and 
# therefore 80% of the times recombination will not occur. 
# number of recombination events per meiosis
recom_event <- ceiling(sum(recombination_map[,"c"]))
recombination_map[loci_number + 1,"c"] <-  recom_event - sum(recombination_map[, "c"])
recombination_map[loci_number + 1,"locations_deleterious"] <- recombination_map[loci_number,"locations_deleterious"]
recombination_map[loci_number + 1,"recombination_2"] <- recombination_map[loci_number,"recombination_2"]
recombination_map$accum <- cumsum(recombination_map[, "c"])

location_temp <- location_neutral_loci_analysis
location_temp <- location_temp[order(location_temp)]
location <- lapply(location_temp, function(x){which(recombination_map$locations_deleterious==x)})
neutral_loci_location <-  as.character(location)
loci_location <- location

s <- rlnorm(loci_number, meanlog = log(log_mean), sdlog = log(log_sd))
# s <- rgamma(loci_number, shape = gamma_shape, scale = gamma_scale)
# s values that are too small crash the function to calculate q
# s_small <- s < 0.000000001
# s[s_small] <- 0.000000001
# the equation for dominance (h) was taken from Huber 2018 Nature
h <- rnorm(loci_number,mean = dominance_mean,sd = sqrt(0.001))
  # 1 / ((1 / intercept) - (-1 * rate * s))
a <- s * (1 - (2 * h))
b <- (h * s) * (1 + mutation_rate)
c <- rep.int(-(mutation_rate), times = loci_number)
df_q <- as.data.frame(cbind(a, b, c))
# q is based on the following equation: (s(1-2h)q^2) + (hs(1+u)q) - u = 0, where u is
# the mutation rate per generation per site. Taken from Crow & Kimura page 260
q <- mapply(q_equilibrium, a = df_q$a,b = df_q$b,c = df_q$c,USE.NAMES = F)
reference <- as.data.frame(matrix(nrow = loci_number))
reference$q <- q
reference$h <- h
reference$s <- s
# NS with very small s have a q > 1. Therefore, we set a maximum q value of 0.5.
q_more_than_point5 <- as.numeric(row.names(reference[reference$q > 0.5, ]))
reference[q_more_than_point5, "q"] <- 0.5
# the log normal distribution, whith the parameters used in the simulations, generates a few selection coefficients that are > 1. the maximum value of s is set to 0.99
s_more_than_one <- as.numeric(row.names(reference[reference$s > 1, ]))
reference[s_more_than_one, "s"] <- 0.99
loci_number <- nrow(reference)
}
}


if(starting_pops==T){
recom_event <- ceiling(sum(recombination_map[,"c"]))
neutral_loci_location <-  as.character(loci_location)
location_neutral_loci_analysis <- reference[unlist(loci_location),"location"]
    if(experiment_freq==T){
loc_exp_loci <- location_neutral_loci_analysis
loc_exp_loci <- loc_exp_loci[order(loc_exp_loci)]
loc_exp_loci <- which(loc_exp_loci %% 10000 != 0)    
loc_exp_loci_2 <- unlist(lapply(location_msats_experiment, function(x){which(x==recombination_map$locations_deleterious)}))
    }
}


##### REFERENCE VALUES BOTH SIMULATIONS #####
# This is to calculate the density of mutations per centimorgan. the density is based on the number of 
# heterozygous loci in each individual. Based on HW equation (p^2+2pq+q^2), the proportion of heterozygotes 
# (2pq) for each locus is calculated and then averaged. This proportion is then multiplied by the number 
# of loci and divided by the length of the chromosome in centiMorgans. According to Haddrill 2010, the mean
# number of heterozygous deleterious mutations per fly is 5,000 deleterious amino acid mutations per 
# individual, with an estimated mean selection coefficient (sh) of 1.1X10^-5. The chromosome arm 2L has 
# 17% of the total number of non-synonymous mutations and is 55/2 cM long (cM are divided by two because 
# there is no recombination in males), with these parameters the density per cM is (5000*0.17)/(55/2) = 30.9
loci_number <- nrow(recombination_map)-1
freq_deleterious <- reference[-as.numeric(neutral_loci_location), ]
freq_deleterious_b <- mean(2 * (freq_deleterious$q) * (1 - freq_deleterious$q))
density_mutations_per_cm <- (freq_deleterious_b * nrow(freq_deleterious)) / (recombination_map[loci_number, "accum"] * 100)
reference$location <- recombination_map[1:loci_number,"locations_deleterious"]

# if(LD_analyses==T){
  # one is subtracted from the recombination map to account for the last row that was added in the 
  # recombination map to avoid that the recombination function crashes
  # loci_number <- nrow(recombination_map)-1
  plink_map <- as.data.frame(matrix(nrow = loci_number,ncol = 4 ))
  plink_map[,1] <- chromosome_name
  plink_map[,2] <- rownames(recombination_map[-(loci_number+1),])
  plink_map[,3] <- recombination_map[-(loci_number+1),"accum"]
  plink_map[,4] <- recombination_map[-(loci_number+1),"locations_deleterious"]
  
# }
# MIGRATION VARIABLES
# pick which sex is going to be transferred first
  if (number_transfers >= 2) {
    maletran <- TRUE
    femaletran <- TRUE
  } else if (number_transfers == 1) {
    maletran <- TRUE
    femaletran <- FALSE
  }

dispersal_rate <- (number_transfers / transfer_each_gen) / (population_size_dispersal)
Fst_expected <- 1 / ((4 * Ne_fst * dispersal_rate) * ((2 / (2 - 1)) ^ 2) + 1)
# Fst_expected <- 1 / ((4 * Ne_fst * dispersal_rate) * ((100 / (100 - 1)) ^ 2) + 1)

shua_expected <- (0.22 / (sqrt(2 * Ne_fst * dispersal_rate))) - (0.69 / ((2*Ne_fst) * sqrt(dispersal_rate)))
rate_of_loss <- 1 - (1 / (2 * Ne))

##### VARIABLES TO WRITE TO EACH FILE #####
variables_file_a <- c(
"simulation_type",
"chromosome_name",
"pre_adaptation",
"population_size_pre_adaptation",
"gen_number_pre_adaptation",
"population_size_dispersal",
"gen_number_dispersal",
"number_transfers",
"transfer_each_gen",
"same_line",
"msats",
"recombination",
"recombination_males",
"c_gral",
"windows_gral",
"dispersal_dispersal",
"Ne",
"selection",
"natural_selection_model",
"intercept",
"log_mean",
"log_sd",
"dominance_mean",
"mutation_rate",
"loci_number",
"h_gral",
"s_gral",
"q_gral",
"fitness_for_repulsion",
# "gene_size",
"experiment_freq",
"number_offspring",
"variance_offspring",
"map_resolution",
"ld_max_pairwise",
"density_mutations_per_cm",  
"number_iterations"
)
variables_file_b <- c(
simulation_type,
chromosome_name,
pre_adaptation,
population_size_pre_adaptation,
gen_number_pre_adaptation,
population_size_dispersal,
gen_number_dispersal,
number_transfers,
transfer_each_gen,
same_line,
msats,
recombination,
recombination_males,
c_gral,
windows_gral,
dispersal_dispersal,
Ne,
selection,
natural_selection_model,
intercept,
log_mean,
log_sd,
dominance_mean,
mutation_rate,
loci_number,
h_gral,
s_gral,
q_gral, 
fitness_for_repulsion,
# gene_size,
experiment_freq,
number_offspring,
variance_offspring,
map_resolution,
ld_max_pairwise,
density_mutations_per_cm,
number_iterations
)
variables_file <- cbind(variables_file_a,variables_file_b)

# variables to write as name of each file
   if(simulation_type=="general"){
 variables <-  paste0(
     "GRAL",
       "_B_", population_size_dispersal,
     "_C_", c_gral,
     "_D_",  h_gral,
      "_F_",  s_gral
    # "_G",  msats,
     # "_H",  pre_adaptation,
    # "_I",   gamma_scale,
    # "_J",   gamma_shape,
    # "_K",  rate,
    # "_L",  intercept,
    # "_M",  mutation_rate,
    # "_N",  s_gral,
    # "_O", h_gral,
    # "_P",  q_gral,
    # "_Q", c_gral
    # "_R",windows_gral,
    #  "_S",experiment_freq,
    #  "_T", fitness_for_repulsion,
    # "_rep_", iteration,
    # ".csv"
    )
   }
  
 if(simulation_type=="fly"){
    variables <-  paste0(
      "FLY",
      #  "_B_", log_mean,
      # "_C_",   dominance_mean,
      # "_D_",  mutation_rate,
      # "_F_",  selection
      #      "_B_", log_mean,
      # "_C_",   dominance_mean,
      "_D_",  gen_number_dispersal,
      "_F_",  same_line
      # "_G", fdist_pop_history[11,2], #  msats,
      # "_H", fdist_pop_history[3,2], #  pre_adaptation,
      # "_I", fdist_pop_history[22,2], #  gamma_scale,
      # "_J", fdist_pop_history[23,2], #  gamma_shape,
      # "_K", fdist_pop_history[21,2], #  rate,
      # # "_L", fdist_pop_history[20,2], #  intercept,
      # "_M", fdist_pop_history[24,2], #  mutation_rate,
      # # "_N", fdist_pop_history[27,2], # s_gral
      # "_O", fdist_pop_history[26,2], # h_gral,
      # "_P", fdist_pop_history[28,2], #q_gral,
      # "_Q", fdist_pop_history[14,2] #c_gral
      # "_R",fdist_pop_history[15,2], # windows_gral,
      # "_S",fdist_pop_history[31,2] # experiment_freq
      # "_T",fdist_pop_history[29,2] # fitness_for_repulsion,
      # "_rep_", iteration,
      # ".csv"
    )
  }

    # CREATING THE FOLDER TO SAVE RESULTS EACH TIME THE PROGRAM IS RUN
if(neutral_simulations==T){
file.date <- format(Sys.time(), "%H%M%S")
path.folder_sim <- stri_join(getwd(), "/","SIM_Neutral_", variables,file.date, sep = "")
dir.create(file.path(path.folder_sim))
}
if(neutral_simulations==F){
file.date <- format(Sys.time(), "%H%M%S")
path.folder_sim <- stri_join(getwd(), "/","SIM_", variables,file.date, sep = "")
dir.create(file.path(path.folder_sim))
}

